23 合并k个链表 合并,链表,k个,归并 两两合并,递归,
24 翻转前后两个字节 翻转,链表,前后字节 计数,偶数位时与前一位翻转
25 翻转k个字节(顺序变更) 翻转,链表,连续k个字节 将各节点放入list,当累计到k个时,将其翻转(for循环),需注意当链表长度为k的倍数时,因判断条件是.Next==nil,所以在最后还需将最后一个节点加入list并进行翻转
26 返回数组中不同元素的个数 数组,空间复杂度O(1),首首扫描 a/b同时从头扫描,a=b时,b继续往后,!=时a++然后和b交换值,b继续往后直到结束 
27 删除数组中值为val的元素 数组,删除,首尾扫描 同时从首尾开始扫描,首取等于val的位置,尾取不等于val的位置,然后互换,直到首尾扫描相交则结束
28 判断字符串是否完全包含子串 字符串,包含 遍历字符串,当字符与子串第一个字符匹配时,直接截取字符串与子串比较,相等则返回该字符的索引,否则继续遍历
29 计算商 除法,注意溢出 先定符号,随后除数循环减被除数,直到除数比被除数小为止,最终检查溢出
30 判断字符串是否完全包含数组中的子串(任意一种组合) 字符串,数组,包含,滑动窗口,任意一种组合 生成数组对应的map,value记录对应子串的应匹配次数,遍历字符串,取left和right,left作为匹配开始点,right作为子串长度滑动窗口开始点,判断map中是否存在窗口中的单词,若存在且value>0,则value-1,已匹配次数+1(当已匹配次数与数组长度相等时,记录此时的left,并右移left),窗口向后滑动,若存在但value=0,则left右移,直到value=1为止,然后继续滑动窗口,若不存在,则left和right均指向窗口后的下一个单词,随后继续滑动窗口.
31 将数组重新排列成比原排列在字典序中下一个更大的排列 数组,排序,字典序中下一个更大的排列 从后往前找到最长降序序列,将其转换为升序序列,把序列前的元素与序列中第一个大于他的元素互换.当发现是纯降序序列即已是最大值时,将其转为最小值
32 查找最长的括号组合 括号组合,最长 先生成每个字符状态的数组,若能和前面配对上,则记为2否则为0,再从左开始检查,若record[i]==2,record[j]==0,且record[j+1:i]中没有0,则record[i]=1,record[j]=1,最后统计数组中最多的连续为1的次数
33 在被翻转的有序不重复数组中查找指定值 有序数组,翻转,不重复,二分查找 先计算旋转距离,随后还原数组进行二分查找时间复杂度O(logn)
34 在有序可重复数组中查找指定值最前/最后的index 有序数组,可重复,查找最前/最后index,二分查找 二分查找,当中间值=目标值时向前后遍历以找到目标值的最前/最后index
35 在有序不可重复数组中找出指定值或此值可被插入的index 有序数组,不可重复,二分查找 二分查找,在迭代中考虑mid的前一位/后一位与target的关系
36 判断数独是否有效 数独,依次检查 依次检查行、列、3*3小方格是否无重复
37 填充数独 数独,遍历填充 遍历数独,依次往'.'的位置填充1-9,随后校验是否和行、列、块造成冲突,若1-9都有冲突,则失败,否则继续
38 根据数字大小生成读法字符串,如1是一,2是在1的基础上处理,1个一即11,3是在2的基础上处理,2个1即21,以此类推 读法字符串 通过for循环实现后一个数在前一个数基础上处理
39 返回数组中数组成目标值的所有组合(数组无重复,数可重复使用) 所有组合,递归,减少余数或减少选择项 先对数组进行排序,随后取出第一个数,出现2种情况:1、余数由数组中的数组成;2、目标数由数组中的其余数组成;以此类推直至余数为0(采纳)或余数小于数组中剩余最小数(丢弃)或数组中无选择项(丢弃)
40 返回数组中数组成目标值的所有组合(数组有重复,数仅可使用一次) 所有组合,递归,减少余数且减少选择项 先对数组进行排序,随后取出第一个数,出现2种情况:1、余数由数组中其余数组成;2、目标数由数组中其余数组成;以此类推直至余数为0(采纳)或余数小于数组中剩余最小数(丢弃)或数组中无选择项(丢弃)
41 返回未排序数组中缺失的最小正整数 数组,未排序,最小正整数,空间复杂度O(n)且空间复杂度O(1) 明确取值空间在[1,len(nums)+1],可用nums[k]存放k+1,当某个k存放的不是对应的k+1时,结果便是此k+1,nums[i] != nums[nums[i]-1] 即 k+1 != nums[k],则将其交换位置,通过for循环交换,最终会将1/2/3...放到其位置上(若nums中存在的话),若nums中不存在,则其位置为其余数,在最后遍历nums即可发现
42 返回数组的储水量 数组,储水量 i点的存水量为min(max(height[:i+1]...), max(height[i:]...)) - height[i],取left数组存储height[:i+1]中的最大值,取right数组存储height[i:]中的最大值,然后取i同时遍历两数组,取left,right中对应较小的
43 返回两个数字组成的string的乘积 字符串,乘积,乘法分解 因乘积的长度一定为两数长度之和或长度之和-1,故设长度为两数长度之和的int数组用于存放各位乘积.乘法可分解为a的第i位与b的第j位相乘,乘积为结果的第i+j+1位,再统一处理进位及最高位的判断,再转换成string
44 判断s能否被p匹配 字符串,匹配,?及* 记录上一个*的位置及*对应匹配s中字符的位置,当出现不匹配又不是?和*时,若出现过*,则回滚,使*继续匹配这次的字符,若没出现过*则返回false,当s已完成匹配而p未完成时,只有p中剩余的均为*时才返回true
45 返回最小跳数 数组,最小跳数 确保每次跳都是最远的,目前的位置+能跳的最大距离即index+nums[index]在nums[i+1:i+nums[i]+1]中是最大的
46 返回不重复数组中数字能组成的所有组合 数组,所有组合,不重复 递归,当前组合的结果基于其子集的结果,如当前组合为{1,2},则有两种组合1-2和2-1,则{1,2,3}有3-1-2,1-3-2,1-2-3,3-2-1,2-3-1,2-1-3 6中组合,在{1,2}的2种组合的基础上产生的
47 返回有重复数组中数字能组成的所有不重复组合 数组,所有不重复组合,有重复 递归,当前组合的结果基于其子集的结果,如当前组合为{1,2},则有两种组合1-2和2-1,则{1,2,3}有3-1-2,1-3-2,1-2-3,3-2-1,2-3-1,2-1-3 6中组合,在{1,2}的2种组合的基础上产生的,在迭代过程中通过map去重
48 返回顺时针旋转90度后的矩阵 矩阵,旋转,原地变换 取一个梯形大小进行对应4个位置依次替换即完成旋转
49 按组返回数组中的字符串,组成字母相同的作为一组 数组,相同字母异序 切分每个单词进而生成对应字母表的string,作为map的key,最后遍历map输出
50 返回乘积 乘积 累乘,当n>2时,n>>1,随后区分奇偶
51 返回N皇后问题的所有解法 N皇后,递归 取l,d1,d2 3个slice用于存储列及左右对角线是否已存在Q,从0开始循环n,判断l,d1,d2对应位置是否为true(即存在),若不存在,将此点设为Q并加入结果,开始递归(即此点设为Q后后续点在此基础上进行的求解,当后续发现在此基础上无解时,会return到此处刚将此点设置为Q的时刻,随后取消Q的设置进行下一次迭代),若存在则直接下一次迭代.此处对于n的循环是判断第一行第n个点能否设为Q.
52 返回N皇后问题的解法数量 N皇后,递归 在51题的基础上取res的len
53 返回连续子数组的最大和 数组,连续,最大和 遍历nums,n对应的sum为n与n-1对应的sum中的较大值,同时更新maxSum
54 将二维数组通过螺旋形转换成一维数组 二维数组,螺旋形 定义4个变量存储上下左右边界,取dx,dy分别表示增量,用x+dx、y+dy与边界的比较来确定拐点
55 判断能否跳到数组最后一个位置 数组,跳数 遍历找0的位置,随后往前遍历看是否有能跳跃过去的index,若有则继续往后遍历找0,若没有则返回false
56 将二维数组中重叠的数组合并 二维数组,重叠,合并 先根据数组的第一个值递增排序,随后逐一比较相邻的数组,有重叠则合并,合并后再与下一个数组比较
57 向有序且子集不相交的二维数组插入数组 二维数组,插入,重叠,合并 遍历intervals与newInterval比较,当intervals[i]较小且无交集时加入res,当newInterval较小且无交集且未被加入时加入res,当有交集时,更新newInterval并continue
58 返回字符串被空格分割后最后一个子串的长度 字符串,空格分割,子串长度 从后遍历,从最后一个不是空格的index开始计数直到再遇到空格
59 螺旋形填充n*n二维数组 二维数组,螺旋形 定义4个变量存储上下左右边界,取dx,dy分别表示增量,用x+dx、y+dy与边界的比较来确定拐点
60 返回1-n所有组合按顺序排列的第k个组合 所有组合,根据规律直接生成 第一个数会出现(n-1)!次,即res[0]=k/(n-1)!,k=k%(n-1)!;第二个数会出现(n-2)!,以此类推...根据此规律逐一生成目标组合中的数即可,需注意每个数仅出现一次
61 返回翻转了k次的链表 链表,翻转 取出链表前k个数,在此期间若next==nil,则可知链表长度,进而简化k(k = k % len(list))使其小于链表长度,随后再次取出链表前k个数,将剩余链表加入结果,随后将链表首位相连,再将next置位nil
62 返回从左上角达到棋盘右下角的路径数 棋盘,仅能向右或向下,路径数 到达(i,j)的路径数=到达(i-1,j)的路径数+到达(i,j-1)的路径数
63 返回从左上角达到棋盘右下角的路径数(含障碍) 棋盘,仅能向右或向下,路径数,含障碍 到达(i,j)的路径数=到达(i-1,j)的路径数+到达(i,j-1)的路径数,当(i,j)为障碍时,此点路径数=0
64 返回从左上角达到棋盘右下角的最短路径值 棋盘,仅能向右或向下,最短路径 到达(i,j)的最小值=min(到达(i-1,j)的最小值,到达(i,j-1)的最小值)+(i,j)
65 校验入参是否是十进制数 十进制,校验 去除前后空格,随后遍历校验字符,小数点个数,是否以e或.e开头
66 返回由数组组成的数字加一后拆分成的数组 数组,加一 从后往前遍历,无需进位时可直接返回,出现类似99需在最高位进位时,需重新申请数组并将第一位置1
67 返回两个二进制字符串的和 字符串,二进制,相加 从后向前遍历,相加,注意进位,string到int再到string的转换通过string(int(a[ka]-'0')+up+'0')实现
68 将数组拆分并组合成满足maxWidth要求的新数组 数组,拆分组合,长度限制 根据maxWidth将words中的词分组,随后针对各组进行组合
69 返回入参的平方根的整数值 平方根 牛顿法
70 返回n级梯子的爬法 爬梯 f(n)=f(n-1)+f(n-2),f(0)=1,f(1)=1,用slice的遍历来代替函数的递归
71 返回输入路径的最简洁形式 路径,最简洁形式 //=/ ./=当前目录 ../=上层目录,用slice及top作为简易栈
72 返回将word1转换成word2所需的最少步骤 字符串,转换 dp[i][j]表示第一个字符串前i个字符到第二个字符串前j个字符需要的编辑距离;若s1[i]==s2[j],dp[i][j]=min(修改:dp[i-1][j-1],删除:dp[i-1][j]+1,增加:dp[i][j-1]+1),若s1[i]!=s2[j],dp[i][j]=min(修改:dp[i-1][j-1],删除:dp[i-1][j],增加:dp[i][j-1])+1,dp[i][0]=i;i=1...m.dp[0][j]=j;j=1...n
73 将矩阵中0所在的行列的值均置为0 矩阵,0所在行列的值置位0 遍历矩阵,当发现某行出现0时,在遍历完该行后将此行全置为0,同时将出现0的列存入map,最后遍历map将对应的列置为0
74 判断已排序的矩阵中是否存在目标数 矩阵,已排序,二分查找 先根据每行的首位确定目标所要比较的行,随后二分法判断是否存在
75 对元素种类较少且大量重复的数据进行in place排序 数组,种类少且重复,排序 取i,k标识首尾,取j从头扫描,遇到0时i与j位置的数交换且i、j均++,遇到1时j继续扫描,遇到2时j与k位置的数交换且k--,直到j>k时返回,此时0-i位置的数均为0,i-j位置额数均为1,j往后的均为2
76 返回字符串中包含字符串2的最小子串 字符串,滑动窗口 统计t中出现的字符及数量,遍历s,当发现需要的字符时,定为窗口的左侧,继续遍历直到窗口包括了t中的所有字符,此时开始收缩左侧窗口直到刚好包括t中所有字符,记为一次满足记录，与已有记录比较,更小时覆盖记录,最终返回最小的记录
77 返回由1至n组成的数组的长度=k的所有组合 数组,所有组合,不重复,长度=k 回溯算法,当某一次形成长度=k的组合后,回溯到之前k-1的长度并继续迭代形成新的组合,当此次k-1的迭代完成后,回溯到长度=k-2继续迭代
78 返回传入数组nums的长度从0-len(nums)各个长度的所有组合 数组,所有组合,不重复,长度从0-len(nums) 在77题的基础上拓展,同样是回溯算法,77题仅需1-n自然数的长度=k的所有组合,而本题是传入数组nums的长度从0-len(nums)的各个长度的所有组合,修改方法c的start入参及nums替换原来的n即可
79 