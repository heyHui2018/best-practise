23 合并k个链表 合并,链表,k个,归并 两两合并,递归,
24 翻转前后两个字节 翻转,链表,前后字节 计数,偶数位时与前一位翻转
25 翻转k个字节(顺序变更) 翻转,链表,连续k个字节 将各节点放入list,当累计到k个时,将其翻转(for循环),需注意当链表长度为k的倍数时,因判断条件是.Next==nil,所以在最后还需将最后一个节点加入list并进行翻转
26 返回数组中不同元素的个数 数组,空间复杂度O(1),首首扫描 a/b同时从头扫描,a=b时,b继续往后,!=时a++然后和b交换值,b继续往后直到结束 
27 删除数组中值为val的元素 数组,删除,首尾扫描 同时从首尾开始扫描,首取等于val的位置,尾取不等于val的位置,然后互换,直到首尾扫描相交则结束
28 判断字符串是否完全包含子串 字符串,包含 遍历字符串,当字符与子串第一个字符匹配时,直接截取字符串与子串比较,相等则返回该字符的索引,否则继续遍历
29 计算商 除法,注意溢出 先定符号,随后除数循环减被除数,直到除数比被除数小为止,最终检查溢出
30 判断字符串是否完全包含数组中的子串(任意一种组合) 字符串,数组,包含,滑动窗口,任意一种组合 生成数组对应的map,value记录对应子串的应匹配次数,遍历字符串,取left和right,left作为匹配开始点,right作为子串长度滑动窗口开始点,判断map中是否存在窗口中的单词,若存在且value>0,则value-1,已匹配次数+1(当已匹配次数与数组长度相等时,记录此时的left,并右移left),窗口向后滑动,若存在但value=0,则left右移,直到value=1为止,然后继续滑动窗口,若不存在,则left和right均指向窗口后的下一个单词,随后继续滑动窗口.
31 将数组重新排列成比原排列在字典序中下一个更大的排列 数组,排序,字典序中下一个更大的排列 从后往前找到最长降序序列,将其转换为升序序列,把序列前的元素与序列中第一个大于他的元素互换.当发现是纯降序序列即已是最大值时,将其转为最小值
32 查找最长的括号组合 括号组合,最长 先生成每个字符状态的数组,若能和前面配对上,则记为2否则为0,再从左开始检查,若record[i]==2,record[j]==0,且record[j+1:i]中没有0,则record[i]=1,record[j]=1,最后统计数组中最多的连续为1的次数
33 在被翻转的有序不重复数组中查找指定值 有序数组,翻转,不重复,二分查找 先计算旋转距离,随后还原数组进行二分查找时间复杂度O(logn)
34 在有序可重复数组中查找指定值最前/最后的index 有序数组,可重复,查找最前/最后index,二分查找 二分查找,当中间值=目标值时向前后遍历以找到目标值的最前/最后index
35 在有序不可重复数组中找出指定值或此值可被插入的index 有序数组,不可重复,二分查找 二分查找,在迭代中考虑mid的前一位/后一位与target的关系
36 判断数独是否有效 数独,依次检查 依次检查行、列、3*3小方格是否无重复
37 填充数独 数独,遍历填充 遍历数独,依次往'.'的位置填充1-9,随后校验是否和行、列、块造成冲突,若1-9都有冲突,则失败,否则继续
38 根据数字大小生成读法字符串,如1是一,2是在1的基础上处理,1个一即11,3是在2的基础上处理,2个1即21,以此类推 读法字符串 通过for循环实现后一个数在前一个数基础上处理
39 返回数组中数组成目标值的所有组合(数组无重复,数可重复使用) 所有组合,递归,减少余数或减少选择项 先对数组进行排序,随后取出第一个数,出现2种情况:1、余数由数组中的数组成;2、目标数由数组中的其余数组成;以此类推直至余数为0(采纳)或余数小于数组中剩余最小数(丢弃)或数组中无选择项(丢弃)
40 返回数组中数组成目标值的所有组合(数组有重复,数仅可使用一次) 所有组合,递归,减少余数且减少选择项 先对数组进行排序,随后取出第一个数,出现2种情况:1、余数由数组中其余数组成;2、目标数由数组中其余数组成;以此类推直至余数为0(采纳)或余数小于数组中剩余最小数(丢弃)或数组中无选择项(丢弃)
41 返回未排序数组中缺失的最小正整数 数组,未排序,最小正整数,空间复杂度O(n)且空间复杂度O(1) 明确取值空间在[1,len(nums)+1],可用nums[k]存放k+1,当某个k存放的不是对应的k+1时,结果便是此k+1,nums[i] != nums[nums[i]-1] 即 k+1 != nums[k],则将其交换位置,通过for循环交换,最终会将1/2/3...放到其位置上(若nums中存在的话),若nums中不存在,则其位置为其余数,在最后遍历nums即可发现
42 返回数组的储水量 数组,储水量 i点的存水量为min(max(height[:i+1]...), max(height[i:]...)) - height[i],取left数组存储height[:i+1]中的最大值,取right数组存储height[i:]中的最大值,然后取i同时遍历两数组,取left,right中对应较小的
43 返回两个数字组成的string的乘积 字符串,乘积,乘法分解 因乘积的长度一定为两数长度之和或长度之和-1,故设长度为两数长度之和的int数组用于存放各位乘积.乘法可分解为a的第i位与b的第j位相乘,乘积为结果的第i+j+1位,再统一处理进位及最高位的判断,再转换成string
44 判断s能否被p匹配 字符串,匹配,?及* 记录上一个*的位置及*对应匹配s中字符的位置,当出现不匹配又不是?和*时,若出现过*,则回滚,使*继续匹配这次的字符,若没出现过*则返回false,当s已完成匹配而p未完成时,只有p中剩余的均为*时才返回true
45 返回最小跳数 数组,最小跳数 确保每次跳都是最远的,目前的位置+能跳的最大距离即index+nums[index]在nums[i+1:i+nums[i]+1]中是最大的
46 返回不重复数组中数字能组成的所有组合 数组,所有组合,不重复 递归,当前组合的结果基于其子集的结果,如当前组合为{1,2},则有两种组合1-2和2-1,则{1,2,3}有3-1-2,1-3-2,1-2-3,3-2-1,2-3-1,2-1-3 6中组合,在{1,2}的2种组合的基础上产生的
47 返回有重复数组中数字能组成的所有不重复组合 数组,所有不重复组合,有重复 递归,当前组合的结果基于其子集的结果,如当前组合为{1,2},则有两种组合1-2和2-1,则{1,2,3}有3-1-2,1-3-2,1-2-3,3-2-1,2-3-1,2-1-3 6中组合,在{1,2}的2种组合的基础上产生的,在迭代过程中通过map去重
48 返回顺时针旋转90度后的矩阵 矩阵,旋转,原地变换 取一个梯形大小进行对应4个位置依次替换即完成旋转
49 按组返回数组中的字符串,组成字母相同的作为一组 数组,相同字母异序 切分每个单词进而生成对应字母表的string,作为map的key,最后遍历map输出
50 返回乘积 乘积 累乘,当n>2时,n>>1,随后区分奇偶
51 返回N皇后问题的所有解法 N皇后,递归 取l,d1,d2 3个slice用于存储列及左右对角线是否已存在Q,从0开始循环n,判断l,d1,d2对应位置是否为true(即存在),若不存在,将此点设为Q并加入结果,开始递归(即此点设为Q后后续点在此基础上进行的求解,当后续发现在此基础上无解时,会return到此处刚将此点设置为Q的时刻,随后取消Q的设置进行下一次迭代),若存在则直接下一次迭代.此处对于n的循环是判断第一行第n个点能否设为Q.
52 返回N皇后问题的解法数量 N皇后,递归 在51题的基础上取res的len
53 返回连续子数组的最大和 数组,连续,最大和 遍历nums,n对应的sum为n与n-1对应的sum中的较大值,同时更新maxSum
54 将二维数组通过螺旋形转换成一维数组 二维数组,螺旋形 定义4个变量存储上下左右边界,取dx,dy分别表示增量,用x+dx、y+dy与边界的比较来确定拐点
55 判断能否跳到数组最后一个位置 数组,跳数 遍历找0的位置,随后往前遍历看是否有能跳跃过去的index,若有则继续往后遍历找0,若没有则返回false
56 将二维数组中重叠的数组合并 二维数组,重叠,合并 先根据数组的第一个值递增排序,随后逐一比较相邻的数组,有重叠则合并,合并后再与下一个数组比较
57 向有序且子集不相交的二维数组插入数组 二维数组,插入,重叠,合并 遍历intervals与newInterval比较,当intervals[i]较小且无交集时加入res,当newInterval较小且无交集且未被加入时加入res,当有交集时,更新newInterval并continue
58 返回字符串被空格分割后最后一个子串的长度 字符串,空格分割,子串长度 从后遍历,从最后一个不是空格的index开始计数直到再遇到空格
59 螺旋形填充n*n二维数组 二维数组,螺旋形 定义4个变量存储上下左右边界,取dx,dy分别表示增量,用x+dx、y+dy与边界的比较来确定拐点
60 返回1-n所有组合按顺序排列的第k个组合 所有组合,根据规律直接生成 第一个数会出现(n-1)!次,即res[0]=k/(n-1)!,k=k%(n-1)!;第二个数会出现(n-2)!,以此类推...根据此规律逐一生成目标组合中的数即可,需注意每个数仅出现一次
61 返回翻转了k次的链表 链表,翻转 取出链表前k个数,在此期间若next==nil,则可知链表长度,进而简化k(k = k % len(list))使其小于链表长度,随后再次取出链表前k个数,将剩余链表加入结果,随后将链表首位相连,再将next置位nil
62 返回从左上角达到棋盘右下角的路径数 棋盘,仅能向右或向下,路径数 到达(i,j)的路径数=到达(i-1,j)的路径数+到达(i,j-1)的路径数
63 返回从左上角达到棋盘右下角的路径数(含障碍) 棋盘,仅能向右或向下,路径数,含障碍 到达(i,j)的路径数=到达(i-1,j)的路径数+到达(i,j-1)的路径数,当(i,j)为障碍时,此点路径数=0
64 返回从左上角达到棋盘右下角的最短路径值 棋盘,仅能向右或向下,最短路径 到达(i,j)的最小值=min(到达(i-1,j)的最小值,到达(i,j-1)的最小值)+(i,j)
65 校验入参是否是十进制数 十进制,校验 去除前后空格,随后遍历校验字符,小数点个数,是否以e或.e开头
66 返回由数组组成的数字加一后拆分成的数组 数组,加一 从后往前遍历,无需进位时可直接返回,出现类似99需在最高位进位时,需重新申请数组并将第一位置1
67 返回两个二进制字符串的和 字符串,二进制,相加 从后向前遍历,相加,注意进位,string到int再到string的转换通过string(int(a[ka]-'0')+up+'0')实现
68 将数组拆分并组合成满足maxWidth要求的新数组 数组,拆分组合,长度限制 根据maxWidth将words中的词分组,随后针对各组进行组合
69 返回入参的平方根的整数值 平方根 牛顿法
70 返回n级梯子的爬法 爬梯 f(n)=f(n-1)+f(n-2),f(0)=1,f(1)=1,用slice的遍历来代替函数的递归
71 返回输入路径的最简洁形式 路径,最简洁形式 //=/ ./=当前目录 ../=上层目录,用slice及top作为简易栈
72 返回将word1转换成word2所需的最少步骤 字符串,转换 dp[i][j]表示第一个字符串前i个字符到第二个字符串前j个字符需要的编辑距离;若s1[i]==s2[j],dp[i][j]=min(修改:dp[i-1][j-1],删除:dp[i-1][j]+1,增加:dp[i][j-1]+1),若s1[i]!=s2[j],dp[i][j]=min(修改:dp[i-1][j-1],删除:dp[i-1][j],增加:dp[i][j-1])+1,dp[i][0]=i;i=1...m.dp[0][j]=j;j=1...n
73 将矩阵中0所在的行列的值均置为0 矩阵,0所在行列的值置位0 遍历矩阵,当发现某行出现0时,在遍历完该行后将此行全置为0,同时将出现0的列存入map,最后遍历map将对应的列置为0
74 判断已排序的矩阵中是否存在目标数 矩阵,已排序,二分查找 先根据每行的首位确定目标所要比较的行,随后二分法判断是否存在
75 对元素种类较少且大量重复的数据进行in place排序 数组,种类少且重复,排序 取i,k标识首尾,取j从头扫描,遇到0时i与j位置的数交换且i、j均++,遇到1时j继续扫描,遇到2时j与k位置的数交换且k--,直到j>k时返回,此时0-i位置的数均为0,i-j位置额数均为1,j往后的均为2
76 返回字符串中包含字符串2的最小子串 字符串,滑动窗口 统计t中出现的字符及数量,遍历s,当发现需要的字符时,定为窗口的左侧,继续遍历直到窗口包括了t中的所有字符,此时开始收缩左侧窗口直到刚好包括t中所有字符,记为一次满足记录，与已有记录比较,更小时覆盖记录,最终返回最小的记录
77 返回由1至n组成的数组的长度=k的所有组合 数组,所有组合,不重复,长度=k 回溯算法,当某一次形成长度=k的组合后,回溯到之前k-1的长度并继续迭代形成新的组合,当此次k-1的迭代完成后,回溯到长度=k-2继续迭代
78 返回传入数组nums(无重复)的长度从0-len(nums)各个长度的所有组合 数组,所有组合,不重复,长度从0-len(nums) 在77题的基础上拓展,同样是回溯算法,77题仅需1-n自然数的长度=k的所有组合,而本题是传入数组nums的长度从0-len(nums)的各个长度的所有组合,修改方法c的start入参及nums替换原来的n即可
79 判断矩阵中是否存在某字符串 矩阵,存在字符串,字符不重复使用 遍历board寻找与word中第一个字符匹配的字符board[i][j],找到后在该字符周围寻找与word中第二个字符匹配的字符,以此类推直至全部找到,否则返回false
80 返回已排序有重复数组中经处理字符最多重复2次后的有效长度 数组,已排序,有重复 取i表示处理完成的数的下标,取j=i往后遍历,当nums[i-2]!=nums[j]即发现一个新的数时,将i位置的数与j位置的数交换并将i+1,此时j的值也+1,继续遍历
81 判断在被翻转的有序有重复数组中是否存在指定值 有序数组,翻转,有重复,二分查找 33题的延伸,可直接使用二分法,33题中的数组无重复,故可直接比较中间值与最右值,当中间值较小时,右半段有序,中间值较大时,左半段有序(原数组升序排列),本题数组有重复,会出现中间值等于最右值的情况,可将最右值左移直到与中间值不相等为止
82 返回被去重后的链表(去重指重复的节点均去除) 链表,完全去重 当head.Next为空时返回,否则判断head的val与next的val是否相等,若相等,则迭代到一个不相等的next并覆盖head,若不相等,则用前面的方法递归处理后续节点
83 返回被去重后的链表(去重指重复的节点保留一个) 链表,去重 遍历链表,取tempVal记录临时val,tempNode记录当前最后一个有效节点,当发现当前val=tempVal时,若当前节点next==nil,则将tempNode的next置为nil以使其成为最后一个节点,若!=nil,则head = head.Next继续遍历;当val!=tempVal时,更新tempVal,将当前节点链接上tempNode,并更新tempNode,后续处理同上
84 返回数组所形成的柱状图中能组成的最大矩形的面积 数组,最大面积 遍历数组,同时取left/right从i开始向两边遍历,遇到边界或值小于heights[i]时停止,并计算面积,迭代出最大的面积.需注意当left=0且heights[0]>heights[i]时,left不用+1
85 返回矩阵中包含的最大矩形的面积 矩阵,最大矩形 统计矩阵每一列在每一行上,从这一列开始往后连续的1的个数(即遇到0停止计数)从而形成数组,随后采用84题中计算数组能形成的最大矩形的算法来计算此数组,最终迭代出矩阵能形成的最大矩形
86 对链表进行排序 链表,排序 遍历链表,val小于x时将节点链接上smaller,否则链接上larger,最后将larger链接上smaller,需注意当有larger时要将larger的最后一个节点的next置为nil
87 判断两个字符串是否互为搅拌字符串 字符串,搅拌字符串 递归.遍历判断两个字符是否存在某一次分割,能使s1的某一子串与s2的某一子串互为搅拌字符,s1的另一子串与s2的另一子串互为搅拌字符,一旦存在则返回true,否则返回false
88 合并两个有序数组 数组,合并 从后往前处理可避免频繁交换.遍历nums2,与nums1中的数从后往前比较,若nums2中的数较大,则将其放在nums1的未排序的最后并继续遍历,若nums1中的数较大,则将其放在nums1的未排序的最后,并取nums1中的前一个数继续与nums2中的数比较直到nums2中的数被放到nums1的未排序的最后才开始下一轮遍历
89 返回n位的格雷码 格雷码 直接排列:以二进制的0值为第零项,第一项改变最右边的位元,第二项改变右起第一个为1的位元的左边位元,第三、四项方法同第一、二项,以此类推.镜射排列:n位元的格雷码可以从n-1位元的格雷码以上下镜射后加上新位元的方式得到,利用以下规则构造:1、1位格雷码有两个码字;2、(n+1)位格雷码中的前2^n个码字等于n位格雷码的码字,按顺序书写,加前缀0;3、(n+1)位格雷码中的后2^n个码字等于n位格雷码的码字,按逆序书写,加前缀1
90 返回传入数组nums(有重复)的长度从0-len(nums)各个长度的所有组合 数组,所有组合,有重复,长度从0-len(nums) 在78题的基础上拓展,同样是回溯算法,78题仅需传入数组nums的长度从0-len(nums)的各个长度的所有组合,这里的nums是无重复的,修改方法s多传入一个map用于过滤即可
91 返回按字母表分解字符串的方法数 字符串,分解,动态规划,类裴波那契数列 取一维数组dp,长度=s+1,dp[i]表示s中前i个字符的解码方式数,取dp[0]=1,当s[1]=0时,因0不对应字符故结果=0,否则dp[1]=1.当s[i]!=0时,dp[i]先赋值dp[i-1],否则赋值0,随后判断s[i-1]是否存在,若存在且与s[i]组合后>0且<=26,则dp[i]=dp[i-1]+dp[i-2],最后返回dp[len(dp)-1]即可
92 将链表中从m到n的部分翻转 链表,翻转 定位mPre和nNext,从mNode开始翻转,随后连接上mPre和nNext.在定位nNext后,需在nNode处使head.Next=nil以便翻转
93 返回字符串可被拆分成的所有ip地址的组合 字符串,ip地址,所有组合 递归.从ip的第0段开始处理,for循环处理每一段ip的长度可能性,循环中判断长度是否满足要求,值是否合法等,若成立则递归下一段ip段,否则continue至下一个for循环
94 返回树的中序遍历 树,中序遍历 递归.结果集加入左子树递归值,加入根节点,加入又子树递归值,当根节点==nil或左右子树均==nil时结束递归.遍历.通过栈实现,当当前节点不为空时,循环入栈左子树,当前节点指向左子树,直到当前节点为空;若此时栈为空则退出(此步判断在左子树处理之后),随后从栈中取出并加入结果集,再将当前节点指向右子树并继续循环.
95 返回1~n组成的数组所能生成的所有二分搜索树 树,二分搜索树,所有组合 f(n)的根的情况有n种(1~n),对于根i,左子树取值1~i-1(即f(i-1)),右子树取值i+1~n(即f(n-i),但各值需+i),则f(n) = ∑f(i-1)*f(n-i) (i=1...n)
96 返回1~n组成的数组所能生成的所有二分搜索树的数量 树,二分搜索树,所有组合数量,卡特兰数 n=0,res=1;n=1,res=1;n=2,res=2;n=3;res=5;res(n)=res(0)*res(n-1)+res(1)*res(n-2)+...+res(n-1)*res(0)卡特兰数
97 判断s3是否由s1与s2交错组成 字符串,交错组成 动态规划.dp[i][j] == true 表示 s1[:i] 和 s2[:j] 可以生成 s3[:i+j]
98 判断传入的树是否是二分搜索树 树,二分搜索树 递归,同时传入当前根节点应属于的大小范围,左子树及其子树应小于根节点,右子树同理,递归时不断更新大小范围
99 复原有位置错误的二分搜索树 树,二分搜索树,中序遍历 1、中序遍历后将节点放入数组,随后将数组排序,最后将数组转换成树;2、在1的基础上改进,中序遍历,因有两节点位置错误,故遍历中能遇到1或2次降序,若仅一次,则直接交换两节点,若两次,则交换第一次的较大点与第二次的较小点
100 判断两棵树是否完全相同 树,是否相同 比较当前节点是否为空,值是否相同,再递归比较左子树和右子树
101 判断树是否是对称的 树,是否对称 与100Same Tree类似,不同点在于从根节点往下分成两棵树后,要判断的是左子树的左子树与右子树的右子树是否same,左子树的右子树与右子树的左子树是否same
102 返回树组成的二维数组 树,二维数组,递归 递归.递归时传入切片指针及深度(即所属二维切片res中的第几个切片),当len(res)<level时,先初始化属于当前level的第二维切片
103 返回树组成的之字形二维数组 树,二维数组,递归,之字形 递归时传入切片指针及深度(即所属二维切片res中的第几个切片),当len(res)<level时,先初始化属于当前level的第二维切片,当level%2==0即偶数时,照常添加,奇数时,将res中对应level第二维切片内的数组添加到当前root的val后
104 返回树的深度 树,深度 递归.root == nil时返回,取两个子节点中值较大者返回
105 根据先序遍历和中序遍历构造二叉树 树,先序遍历,中序遍历,构造树 递归.preorder[0]为根节点,找到inorder中preorder[0]的位置i,preorder[1:i+1]和inorder[:i]为左子树,preorder[i+1:]和inorder[i+1:]为右子树,随后继续递归
106 